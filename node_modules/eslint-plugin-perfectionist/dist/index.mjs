import B from "node:path";
import { ESLintUtils as ne, ASTUtils as D } from "@typescript-eslint/utils";
import { minimatch as $ } from "minimatch";
import le from "natural-compare-lite";
import { builtinModules as ie } from "node:module";
let O = ne.RuleCreator(
  (s) => `https://eslint-plugin-perfectionist.azat.io/rules/${s}`
), x = (s, l) => {
  for (let n = 0, a = s.length; n < a; n++) {
    let u = s[n];
    if (l.group === u || Array.isArray(u) && typeof l.group == "string" && u.includes(l.group))
      return n;
  }
  return s.length;
}, v = (s) => {
  let [l, n] = s;
  return n - l;
}, j = (s) => s > 0;
var i = /* @__PURE__ */ ((s) => (s.alphabetical = "alphabetical", s["line-length"] = "line-length", s.natural = "natural", s))(i || {}), f = /* @__PURE__ */ ((s) => (s.desc = "desc", s.asc = "asc", s))(f || {});
let M = (s) => {
  let l, n = (u) => {
    !l && s.flat().includes(u) && (l = u);
  };
  return {
    getGroup: () => l ?? "unknown",
    setCustomGroups: (u, t) => {
      if (u)
        for (let [e, o] of Object.entries(u))
          Array.isArray(o) && o.some(
            (r) => $(t, r, {
              nocomment: !0
            })
          ) && n(e), typeof o == "string" && $(t, o, {
            nocomment: !0
          }) && n(e);
    },
    defineGroup: n
  };
}, w = (s, l, n) => {
  var e, o;
  if ((e = l.dependencies) != null && e.includes(s.name))
    return -1;
  if ((o = s.dependencies) != null && o.includes(l.name))
    return 1;
  let a = n.order === "asc" ? 1 : -1, u, t = (r) => n["ignore-case"] ? r.toLowerCase() : r;
  return n.type === i.alphabetical ? u = (r, c) => t(r.name).localeCompare(t(c.name)) : n.type === i.natural ? u = (r, c) => le(t(r.name), t(c.name)) : u = (r, c) => r.size - c.size, a * u(s, l);
}, A = (s, l) => [...s].sort((n, a) => w(n, a, l)), pe = (s, l) => {
  let n = l.getTokenAfter(s, {
    filter: ({ value: a, type: u }) => !(u === "Punctuator" && [",", ";"].includes(a)),
    includeComments: !0
  });
  return ((n == null ? void 0 : n.type) === "Block" || (n == null ? void 0 : n.type) === "Line") && s.loc.end.line === n.loc.end.line ? n : null;
}, oe = (s, l) => Array.isArray(s) && s.some(
  (n) => $(l.trim(), n, {
    nocomment: !0
  })
) || typeof s == "string" && $(l.trim(), s, {
  nocomment: !0
}) || s === !0, _ = (s, l) => {
  let [n, a] = l.getTokensBefore(s, {
    filter: ({ value: u, type: t }) => !(t === "Punctuator" && [",", ";"].includes(u)),
    includeComments: !0,
    count: 2
  });
  return ((a == null ? void 0 : a.type) === "Block" || (a == null ? void 0 : a.type) === "Line") && s.loc.start.line - a.loc.end.line <= 1 && (n == null ? void 0 : n.loc.end.line) !== a.loc.start.line ? a : null;
}, G = (s, l, n) => {
  var o;
  let a = s.range.at(0), u = s.range.at(1), t = l.text.slice(a, u);
  if (D.isParenthesized(s, l)) {
    let r = l.getTokenBefore(
      s,
      D.isOpeningParenToken
    ), c = l.getTokenAfter(
      s,
      D.isClosingParenToken
    );
    a = r.range.at(0), u = c.range.at(1);
  }
  let e = _(s, l);
  if (t.endsWith(";") || t.endsWith(",")) {
    let r = l.getTokensAfter(s, {
      includeComments: !0,
      count: 2
    });
    s.loc.start.line === ((o = r.at(1)) == null ? void 0 : o.loc.start.line) && (u -= 1);
  }
  return e && !oe(
    (n == null ? void 0 : n.partitionComment) ?? !1,
    e.value
  ) && (a = e.range.at(0)), [a, u];
}, P = (s, l, n, a, u) => {
  var o, r;
  let t = [], e = ((o = l.at(0)) == null ? void 0 : o.node.loc.start.line) === ((r = l.at(-1)) == null ? void 0 : r.node.loc.end.line);
  for (let c = 0, d = l.length; c < d; c++) {
    let { node: y } = l.at(c);
    t.push(
      s.replaceTextRange(
        G(y, a, u),
        a.text.slice(
          ...G(n.at(c).node, a, u)
        )
      )
    );
    let m = pe(n.at(c).node, a);
    if (m && !e) {
      let p = [
        a.getTokenBefore(m).range.at(1),
        m.range.at(1)
      ];
      t.push(s.replaceTextRange(p, ""));
      let h = a.getTokenAfter(y);
      t.push(
        s.insertTextAfter(
          (h == null ? void 0 : h.loc.end.line) === y.loc.end.line ? h : y,
          a.text.slice(...p)
        )
      );
    }
  }
  return t;
}, k = (s = {}, l) => Object.assign(l, s), C = (s, l) => {
  if (s.length > 1)
    for (let n = 1; n < s.length; n++) {
      let a = s.at(n - 1), u = s.at(n);
      a && u && l(a, u, n - 1);
    }
};
const W = "sort-svelte-attributes", ue = O({
  name: W,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Svelte attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedSvelteAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => B.extname(s.getFilename()) !== ".svelte" ? {} : {
    SvelteStartTag: (l) => {
      if (l.attributes.length > 1) {
        let n = k(s.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), a = s.getSourceCode(), u = l.attributes.reduce(
          (t, e) => {
            if (e.type === "SvelteSpreadAttribute")
              return t.push([]), t;
            let o, { getGroup: r, defineGroup: c, setCustomGroups: d } = M(
              n.groups
            );
            return e.key.type === "SvelteSpecialDirectiveKey" ? o = a.text.slice(...e.key.range) : typeof e.key.name == "string" ? { name: o } = e.key : o = a.text.slice(...e.key.range), d(n["custom-groups"], o), e.type === "SvelteShorthandAttribute" && (c("svelte-shorthand"), c("shorthand")), (!("value" in e) || Array.isArray(e.value) && !e.value.at(0)) && c("shorthand"), e.loc.start.line !== e.loc.end.line && c("multiline"), t.at(-1).push({
              size: v(e.range),
              node: e,
              group: r(),
              name: o
            }), t;
          },
          [[]]
        );
        for (let t of u)
          C(t, (e, o) => {
            let r = x(n.groups, e), c = x(n.groups, o);
            (r > c || r === c && j(w(e, o, n))) && s.report({
              messageId: "unexpectedSvelteAttributesOrder",
              data: {
                left: e.name,
                right: o.name
              },
              node: o.node,
              fix: (d) => {
                let y = {};
                for (let g of t) {
                  let p = x(n.groups, g);
                  p in y ? y[p] = A(
                    [...y[p], g],
                    n
                  ) : y[p] = [g];
                }
                let m = [];
                for (let g of Object.keys(y).sort())
                  m.push(...A(y[g], n));
                return P(d, t, m, a);
              }
            });
          });
      }
    }
  }
}), V = "sort-astro-attributes", ce = O({
  name: V,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Astro attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedAstroAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  // @ts-ignore
  create: (s) => B.extname(s.getFilename()) !== ".astro" ? {} : {
    JSXElement: (l) => {
      let { attributes: n } = l.openingElement;
      if (n.length > 1) {
        let a = k(s.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1,
          "custom-groups": {},
          groups: []
        }), u = s.getSourceCode(), t = n.reduce(
          (e, o) => {
            if (o.type === "JSXSpreadAttribute")
              return e.push([]), e;
            let r = typeof o.name.name == "string" ? o.name.name : u.text.slice(...o.name.range), { getGroup: c, defineGroup: d, setCustomGroups: y } = M(
              a.groups
            );
            return y(a["custom-groups"], r), o.type === "AstroShorthandAttribute" && (d("astro-shorthand"), d("shorthand")), o.value === null && d("shorthand"), o.loc.start.line !== o.loc.end.line && d("multiline"), e.at(-1).push({
              size: v(o.range),
              node: o,
              group: c(),
              name: r
            }), e;
          },
          [[]]
        );
        for (let e of t)
          C(e, (o, r) => {
            let c = x(a.groups, o), d = x(a.groups, r);
            (c > d || c === d && j(w(o, r, a))) && s.report({
              messageId: "unexpectedAstroAttributesOrder",
              data: {
                left: o.name,
                right: r.name
              },
              node: r.node,
              fix: (y) => {
                let m = {};
                for (let p of e) {
                  let h = x(a.groups, p);
                  h in m ? m[h] = A(
                    [...m[h], p],
                    a
                  ) : m[h] = [p];
                }
                let g = [];
                for (let p of Object.keys(m).sort())
                  g.push(...A(m[p], a));
                return P(y, e, g, u);
              }
            });
          });
      }
    }
  }
});
let I = (s) => s.replaceAll(/\s\s+/g, " ").trim();
const J = "sort-array-includes", de = O({
  name: J,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted arrays before include method"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "spread-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedArrayIncludesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    MemberExpression: (l) => {
      if ((l.object.type === "ArrayExpression" || l.object.type === "NewExpression") && l.property.type === "Identifier" && l.property.name === "includes") {
        let n = l.object.type === "ArrayExpression" ? l.object.elements : l.object.arguments;
        if (n.length > 1) {
          let a = k(s.options.at(0), {
            type: i.alphabetical,
            order: f.asc,
            "ignore-case": !1,
            "spread-last": !1
          }), u = s.getSourceCode(), t = n.reduce(
            (e, o) => (o !== null && e.at(0).push({
              name: o.type === "Literal" ? `${o.value}` : u.text.slice(...o.range),
              size: v(o.range),
              type: o.type,
              node: o
            }), e),
            [[], []]
          ).flat();
          C(t, (e, o) => {
            let r;
            a["spread-last"] && e.node.type === "Literal" && o.node.type === "SpreadElement" ? r = !1 : a["spread-last"] && e.node.type === "SpreadElement" && o.node.type === "Literal" ? r = !0 : r = j(w(e, o, a)), r && s.report({
              messageId: "unexpectedArrayIncludesOrder",
              data: {
                left: I(e.name),
                right: I(o.name)
              },
              node: o.node,
              fix: (c) => {
                let d = A(t, a);
                if (a["spread-last"])
                  for (let y = 0, m = d.length; y < m; y++)
                    d.at(y).node.type === "SpreadElement" && d.push(d.splice(y, 1).at(0));
                return P(c, t, d, u);
              }
            });
          });
        }
      }
    }
  })
}), X = "sort-vue-attributes", fe = O({
  name: X,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Vue attributes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedVueAttributesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => {
    if (B.extname(s.getFilename()) !== ".vue")
      return {};
    if (!("defineTemplateBodyVisitor" in s.parserServices))
      return {};
    let { defineTemplateBodyVisitor: l } = s.parserServices;
    return l({
      VStartTag: (n) => {
        if (n.attributes.length > 1) {
          let a = k(s.options.at(0), {
            type: i.alphabetical,
            order: f.asc,
            "ignore-case": !1,
            "custom-groups": {},
            groups: []
          }), u = s.getSourceCode(), t = n.attributes.reduce(
            (e, o) => {
              if (o.key.type === "VDirectiveKey" && o.key.name.rawName === "bind")
                return e.push([]), e;
              let r, { getGroup: c, defineGroup: d, setCustomGroups: y } = M(
                a.groups
              );
              return typeof o.key.name == "string" && o.key.type !== "VDirectiveKey" ? r = o.key.rawName : r = u.text.slice(...o.key.range), y(a["custom-groups"], r), o.value === null && d("shorthand"), o.loc.start.line !== o.loc.end.line && d("multiline"), e.at(-1).push({
                size: v(o.range),
                node: o,
                group: c(),
                name: r
              }), e;
            },
            [[]]
          );
          for (let e of t)
            C(e, (o, r) => {
              let c = x(a.groups, o), d = x(a.groups, r);
              (c > d || c === d && j(w(o, r, a))) && s.report({
                messageId: "unexpectedVueAttributesOrder",
                data: {
                  left: o.name,
                  right: r.name
                },
                node: r.node,
                fix: (y) => {
                  let m = {};
                  for (let p of e) {
                    let h = x(a.groups, p);
                    h in m ? m[h] = A(
                      [...m[h], p],
                      a
                    ) : m[h] = [p];
                  }
                  let g = [];
                  for (let p of Object.keys(m).sort())
                    g.push(...A(m[p], a));
                  return P(y, e, g, u);
                }
              });
            });
        }
      }
    });
  }
}), K = "sort-named-exports", ge = O({
  name: K,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    ExportNamedDeclaration: (l) => {
      if (l.specifiers.length > 1) {
        let n = k(s.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc
        }), a = s.getSourceCode(), u = l.specifiers.map((t) => ({
          size: v(t.range),
          name: t.local.name,
          node: t
        }));
        C(u, (t, e) => {
          j(w(t, e, n)) && s.report({
            messageId: "unexpectedNamedExportsOrder",
            data: {
              left: t.name,
              right: e.name
            },
            node: e.node,
            fix: (o) => P(o, u, A(u, n), a)
          });
        });
      }
    }
  })
}), q = "sort-named-imports", ye = O({
  name: q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted named imports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-alias": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedNamedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    ImportDeclaration: (l) => {
      let n = l.specifiers.filter(
        ({ type: a }) => a === "ImportSpecifier"
      );
      if (n.length > 1) {
        let a = k(s.options.at(0), {
          type: i.alphabetical,
          "ignore-alias": !0,
          "ignore-case": !1,
          order: f.asc
        }), u = s.getSourceCode(), t = n.map((e) => {
          let { name: o } = e.local;
          return a["ignore-alias"] && e.type === "ImportSpecifier" && ({ name: o } = e.imported), {
            size: v(e.range),
            node: e,
            name: o
          };
        });
        C(t, (e, o) => {
          j(w(e, o, a)) && s.report({
            messageId: "unexpectedNamedImportsOrder",
            data: {
              left: e.name,
              right: o.name
            },
            node: o.node,
            fix: (r) => P(r, t, A(t, a), u)
          });
        });
      }
    }
  })
}), F = "sort-object-types", me = O({
  name: F,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted object types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    TSTypeLiteral: (l) => {
      if (l.members.length > 1) {
        let n = k(s.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc,
          "custom-groups": {},
          groups: []
        }), a = s.getSourceCode(), u = l.members.map((t) => {
          var p, h;
          let e, o = a.text.slice(t.range.at(0), t.range.at(1)), { getGroup: r, defineGroup: c, setCustomGroups: d } = M(
            n.groups
          ), y = (S) => S.replace(/(,|;)$/, "");
          if (t.type === "TSPropertySignature")
            t.key.type === "Identifier" ? { name: e } = t.key : t.key.type === "Literal" ? e = `${t.key.value}` : e = a.text.slice(
              t.range.at(0),
              (p = t.typeAnnotation) == null ? void 0 : p.range.at(0)
            );
          else if (t.type === "TSIndexSignature") {
            let S = ((h = t.typeAnnotation) == null ? void 0 : h.range.at(0)) ?? t.range.at(1);
            e = y(a.text.slice(t.range.at(0), S));
          } else
            e = y(
              a.text.slice(t.range.at(0), t.range.at(1))
            );
          d(n["custom-groups"], e), t.loc.start.line !== t.loc.end.line && c("multiline");
          let g = o.endsWith(";") || o.endsWith(",") ? 1 : 0;
          return {
            size: v(t.range) - g,
            group: r(),
            node: t,
            name: e
          };
        });
        C(u, (t, e) => {
          let o = x(n.groups, t), r = x(n.groups, e);
          (o > r || o === r && j(w(t, e, n))) && s.report({
            messageId: "unexpectedObjectTypesOrder",
            data: {
              left: I(t.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (c) => {
              let d = {};
              for (let m of u) {
                let g = x(n.groups, m);
                g in d ? d[g] = A(
                  [...d[g], m],
                  n
                ) : d[g] = [m];
              }
              let y = [];
              for (let m of Object.keys(d).sort())
                y.push(...A(d[m], n));
              return P(c, u, y, a);
            }
          });
        });
      }
    }
  })
}), H = "sort-union-types", he = O({
  name: H,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted union types"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "nullable-last": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedUnionTypesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    TSUnionType: (l) => {
      let n = s.getSourceCode(), a = k(s.options.at(0), {
        type: i.alphabetical,
        "nullable-last": !1,
        "ignore-case": !1,
        order: f.asc
      }), u = l.types.map((t) => ({
        group: t.type === "TSNullKeyword" || t.type === "TSUndefinedKeyword" ? "nullable" : "unknown",
        name: n.text.slice(...t.range),
        size: v(t.range),
        node: t
      }));
      C(u, (t, e) => {
        let o = j(w(t, e, a));
        a["nullable-last"] && (t.group === "nullable" && e.group === "unknown" ? o = !0 : t.group === "unknown" && e.group === "nullable" && (o = !1)), o && s.report({
          messageId: "unexpectedUnionTypesOrder",
          data: {
            left: I(t.name),
            right: I(e.name)
          },
          node: e.node,
          fix: (r) => {
            let c = [];
            if (a["nullable-last"]) {
              let d = [], y = u.filter((m) => m.group === "nullable" ? (d.push(m), !1) : !0);
              c = [
                ...A(y, a),
                ...A(d, a)
              ];
            } else
              c = A(u, a);
            return P(r, u, c, n);
          }
        });
      });
    }
  })
}), Q = "sort-interfaces", be = O({
  name: Q,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted interface properties"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          "ignore-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedInterfacePropertiesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    TSInterfaceDeclaration: (l) => {
      if (l.body.body.length > 1) {
        let n = k(s.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc,
          "ignore-pattern": [],
          "custom-groups": {},
          groups: []
        });
        if (!n["ignore-pattern"].some(
          (a) => $(l.id.name, a, {
            nocomment: !0
          })
        )) {
          let a = s.getSourceCode(), u = l.body.body.reduce(
            (t, e) => {
              var y, m, g;
              if (e.type === "TSCallSignatureDeclaration")
                return t.push([]), t;
              let o, { getGroup: r, defineGroup: c, setCustomGroups: d } = M(
                n.groups
              );
              if (e.type === "TSPropertySignature")
                if (e.key.type === "Identifier")
                  ({ name: o } = e.key);
                else if (e.key.type === "Literal")
                  o = `${e.key.value}`;
                else {
                  let p = ((y = e.typeAnnotation) == null ? void 0 : y.range.at(0)) ?? e.range.at(1) - (e.optional ? 1 : 0);
                  o = a.text.slice(e.range.at(0), p);
                }
              else if (e.type === "TSIndexSignature") {
                let p = ((m = e.typeAnnotation) == null ? void 0 : m.range.at(0)) ?? e.range.at(1);
                o = a.text.slice(e.range.at(0), p);
              } else {
                let p = ((g = e.returnType) == null ? void 0 : g.range.at(0)) ?? e.range.at(1);
                o = a.text.slice(e.range.at(0), p);
              }
              return d(n["custom-groups"], o), e.loc.start.line !== e.loc.end.line && c("multiline"), t.at(-1).push({
                size: v(e.range),
                group: r(),
                node: e,
                name: o
              }), t;
            },
            [[]]
          );
          for (let t of u)
            C(t, (e, o) => {
              let r = x(n.groups, e), c = x(n.groups, o);
              (r > c || r === c && j(w(e, o, n))) && s.report({
                messageId: "unexpectedInterfacePropertiesOrder",
                data: {
                  left: I(e.name),
                  right: I(o.name)
                },
                node: o.node,
                fix: (d) => {
                  let y = {};
                  for (let g of t) {
                    let p = x(n.groups, g);
                    p in y ? y[p] = A(
                      [...y[p], g],
                      n
                    ) : y[p] = [g];
                  }
                  let m = [];
                  for (let g of Object.keys(y).sort())
                    m.push(...A(y[g], n));
                  return P(d, t, m, a);
                }
              });
            });
        }
      }
    }
  })
}), Y = "sort-jsx-props", xe = O({
  name: Y,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted JSX props"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          groups: {
            type: "array"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedJSXPropsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => [".svelte", ".astro", ".vue"].includes(
    B.extname(s.getFilename())
  ) ? {} : {
    JSXElement: (l) => {
      if (l.openingElement.attributes.length > 1) {
        let n = k(s.options.at(0), {
          type: i.alphabetical,
          "ignore-case": !1,
          order: f.asc,
          "custom-groups": {},
          groups: []
        }), a = s.getSourceCode(), u = l.openingElement.attributes.reduce(
          (t, e) => {
            if (e.type === "JSXSpreadAttribute")
              return t.push([]), t;
            let o = e.name.type === "JSXNamespacedName" ? `${e.name.namespace.name}:${e.name.name.name}` : e.name.name, { getGroup: r, defineGroup: c, setCustomGroups: d } = M(
              n.groups
            );
            d(n["custom-groups"], o), e.value === null && c("shorthand"), e.loc.start.line !== e.loc.end.line && c("multiline");
            let y = {
              size: v(e.range),
              group: r(),
              node: e,
              name: o
            };
            return t.at(-1).push(y), t;
          },
          [[]]
        );
        for (let t of u)
          C(t, (e, o) => {
            let r = x(n.groups, e), c = x(n.groups, o);
            (r > c || r === c && j(w(e, o, n))) && s.report({
              messageId: "unexpectedJSXPropsOrder",
              data: {
                left: e.name,
                right: o.name
              },
              node: o.node,
              fix: (d) => {
                let y = {};
                for (let g of t) {
                  let p = x(n.groups, g);
                  p in y ? y[p] = A(
                    [...y[p], g],
                    n
                  ) : y[p] = [g];
                }
                let m = [];
                for (let g of Object.keys(y).sort())
                  m.push(...A(y[g], n));
                return P(d, t, m, a);
              }
            });
          });
      }
    }
  }
}), Z = "sort-exports", Ee = O({
  name: Z,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted exports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedExportsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => {
    let l = k(s.options.at(0), {
      type: i.alphabetical,
      order: f.asc,
      "ignore-case": !1
    }), n = [[]], a = (u) => {
      u.type === "ExportAllDeclaration" && u.exported === null ? n.push([]) : n.at(-1).push({
        size: v(u.range),
        name: u.source.value,
        node: u
      });
    };
    return {
      ExportAllDeclaration: a,
      ExportNamedDeclaration: (u) => {
        u.source !== null && a(u);
      },
      "Program:exit": () => {
        let u = s.getSourceCode();
        for (let t of n)
          C(t, (e, o) => {
            j(w(e, o, l)) && s.report({
              messageId: "unexpectedExportsOrder",
              data: {
                left: e.name,
                right: o.name
              },
              node: o.node,
              fix: (r) => P(r, t, A(t, l), u)
            });
          });
      }
    };
  }
}), ee = "sort-imports", Se = O({
  name: ee,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted imports"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object",
            properties: {
              type: {
                type: "object"
              },
              value: {
                type: "object"
              }
            },
            additionalProperties: !1
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array",
            default: []
          },
          "internal-pattern": {
            items: {
              type: "string"
            },
            type: "array"
          },
          "newlines-between": {
            enum: [
              "ignore",
              "always",
              "never"
              /* never */
            ],
            default: "always",
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedImportsOrder: 'Expected "{{right}}" to come before "{{left}}"',
      missedSpacingBetweenImports: 'Missed spacing between "{{left}}" and "{{right}}" imports',
      extraSpacingBetweenImports: 'Extra spacing between "{{left}}" and "{{right}}" imports'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => {
    let l = k(s.options.at(0), {
      "newlines-between": "always",
      "custom-groups": { type: {}, value: {} },
      "internal-pattern": ["~/**"],
      type: i.alphabetical,
      order: f.asc,
      "ignore-case": !1,
      groups: []
    }), n = !1;
    for (let r of l.groups)
      if (Array.isArray(r))
        for (let c of r)
          c === "unknown" && (n = !0);
      else
        r === "unknown" && (n = !0);
    n || (l.groups = [...l.groups, "unknown"]);
    let a = s.getSourceCode(), u = [], t = (r) => r.type === "ImportDeclaration" && r.specifiers.length === 0, e = (r) => {
      let c = (b) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
        (T) => b.endsWith(T)
      ), d = (b) => [
        "./index.d.js",
        "./index.d.ts",
        "./index.js",
        "./index.ts",
        "./index",
        "./",
        "."
      ].includes(b), y = (b) => b.indexOf("..") === 0, m = (b) => b.indexOf("./") === 0, { getGroup: g, defineGroup: p, setCustomGroups: h } = M(l.groups), S = (b) => l["internal-pattern"].length && l["internal-pattern"].some(
        (T) => $(b.source.value, T, {
          nocomment: !0
        })
      ), N = (b) => {
        let T = [
          "bun",
          "bun:ffi",
          "bun:jsc",
          "bun:sqlite",
          "bun:test",
          "bun:wrap",
          "detect-libc",
          "undici",
          "ws"
        ];
        return ie.includes(
          b.startsWith("node:") ? b.split("node:")[1] : b
        ) || T.includes(b);
      }, E = (b) => !(b.startsWith(".") || b.startsWith("/"));
      return r.importKind === "type" && (r.type === "ImportDeclaration" && (h(l["custom-groups"].type, r.source.value), d(r.source.value) && p("index-type"), m(r.source.value) && p("sibling-type"), y(r.source.value) && p("parent-type"), S(r) && p("internal-type"), N(r.source.value) && p("builtin-type"), E(r.source.value) && p("external-type")), p("type")), r.type === "ImportDeclaration" && (h(l["custom-groups"].value, r.source.value), t(r) && p("side-effect"), c(r.source.value) && p("style"), d(r.source.value) && p("index"), m(r.source.value) && p("sibling"), y(r.source.value) && p("parent"), S(r) && p("internal"), N(r.source.value) && p("builtin"), E(r.source.value) && p("external")), g();
    }, o = (r) => {
      let c;
      r.type === "ImportDeclaration" ? c = r.source.value : r.moduleReference.type === "TSExternalModuleReference" && r.moduleReference.expression.type === "Literal" ? c = `${r.moduleReference.expression.value}` : c = a.text.slice(...r.moduleReference.range), u.push({
        size: v(r.range),
        group: e(r),
        name: c,
        node: r
      });
    };
    return {
      TSImportEqualsDeclaration: o,
      ImportDeclaration: o,
      "Program:exit": () => {
        var m;
        let r = (g, p) => !!a.getTokensBetween(
          g.node,
          _(p.node, a) || p.node,
          {
            includeComments: !0
          }
        ).length, c = (g, p) => a.lines.slice(
          g.node.loc.end.line,
          p.node.loc.start.line - 1
        ).filter((S) => !S.trim().length).length, d = (g, p) => {
          let h = [], S = {};
          for (let E of p) {
            let b = x(l.groups, E);
            b in S ? S[b] = A(
              [...S[b], E],
              l
            ) : S[b] = [E];
          }
          let N = Object.keys(S).sort().reduce(
            (E, b) => [
              ...E,
              ...S[b]
            ],
            []
          );
          for (let E = 0, b = N.length; E < b; E++) {
            let T = N.at(E);
            if (h.push(
              g.replaceTextRange(
                G(p.at(E).node, a),
                a.text.slice(...G(T.node, a))
              )
            ), l["newlines-between"] !== "ignore") {
              let L = N.at(E + 1);
              if (L) {
                let R = c(
                  p.at(E),
                  p.at(E + 1)
                );
                (l["newlines-between"] === "always" && x(l.groups, T) === x(l.groups, L) && R !== 0 || l["newlines-between"] === "never" && R > 0) && h.push(
                  g.removeRange([
                    G(p.at(E).node, a).at(1),
                    G(p.at(E + 1).node, a).at(0) - 1
                  ])
                ), l["newlines-between"] === "always" && x(l.groups, T) !== x(l.groups, L) && R > 1 && h.push(
                  g.replaceTextRange(
                    [
                      G(p.at(E).node, a).at(1),
                      G(p.at(E + 1).node, a).at(
                        0
                      ) - 1
                    ],
                    `
`
                  )
                ), l["newlines-between"] === "always" && x(l.groups, T) !== x(l.groups, L) && R === 0 && h.push(
                  g.insertTextAfterRange(
                    G(p.at(E).node, a),
                    `
`
                  )
                );
              }
            }
          }
          return h;
        }, y = [[]];
        for (let g of u) {
          let p = (m = y.at(-1)) == null ? void 0 : m.at(-1);
          p && r(p, g) ? y.push([g]) : y.at(-1).push(g);
        }
        for (let g of y)
          C(g, (p, h) => {
            let S = x(l.groups, p), N = x(l.groups, h), E = c(p, h);
            !(t(p.node) && t(h.node)) && !r(p, h) && (S > N || S === N && j(w(p, h, l))) && s.report({
              messageId: "unexpectedImportsOrder",
              data: {
                left: p.name,
                right: h.name
              },
              node: h.node,
              fix: (b) => d(b, g)
            }), l["newlines-between"] === "never" && E > 0 && s.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: p.name,
                right: h.name
              },
              node: h.node,
              fix: (b) => d(b, g)
            }), l["newlines-between"] === "always" && (S < N && E === 0 ? s.report({
              messageId: "missedSpacingBetweenImports",
              data: {
                left: p.name,
                right: h.name
              },
              node: h.node,
              fix: (b) => d(b, g)
            }) : (E > 1 || S === N && E > 0) && s.report({
              messageId: "extraSpacingBetweenImports",
              data: {
                left: p.name,
                right: h.name
              },
              node: h.node,
              fix: (b) => d(b, g)
            }));
          });
      }
    };
  }
}), te = "sort-objects", Ae = O({
  name: te,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted objects"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          "custom-groups": {
            type: "object"
          },
          "partition-by-comment": {
            type: ["boolean", "string", "array"],
            default: !1
          },
          "styled-components": {
            type: "boolean",
            default: !0
          },
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          groups: {
            type: "array"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedObjectsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => {
    let l = (n) => {
      if (n.properties.length > 1) {
        let a = k(s.options.at(0), {
          "partition-by-comment": !1,
          type: i.alphabetical,
          "styled-components": !0,
          "ignore-case": !1,
          order: f.asc,
          "custom-groups": {},
          groups: []
        }), u = (r) => r.type === "Identifier" && r.name === "styled", t = (r) => r !== void 0 && r.type === "CallExpression" && (r.callee.type === "MemberExpression" && u(r.callee.object) || r.callee.type === "CallExpression" && u(r.callee.callee));
        if (!a["styled-components"] && (t(n.parent) || n.parent.type === "ArrowFunctionExpression" && t(n.parent.parent)))
          return;
        let e = s.getSourceCode(), o = (r) => r.reduce(
          (c, d) => {
            if (d.type === "SpreadElement" || d.type === "RestElement")
              return c.push([]), c;
            let y = _(d, e);
            a["partition-by-comment"] && y && oe(
              a["partition-by-comment"],
              y.value
            ) && c.push([]);
            let m, g = "ignore", p = [], { getGroup: h, setCustomGroups: S } = M(a.groups);
            d.key.type === "Identifier" ? { name: m } = d.key : d.key.type === "Literal" ? m = `${d.key.value}` : m = e.text.slice(...d.key.range), d.value.type === "AssignmentPattern" && ((b) => {
              b.right.type === "Identifier" && p.push(b.right.name);
              let T = (L) => {
                let R = [];
                switch (L.type) {
                  case "ArrowFunctionExpression":
                    R.push(L.body);
                    break;
                  case "ConditionalExpression":
                    R.push(L.consequent, L.alternate);
                    break;
                  case "LogicalExpression":
                  case "BinaryExpression":
                    R.push(L.left, L.right);
                    break;
                  case "CallExpression":
                    R.push(...L.arguments);
                    break;
                }
                R.forEach((U) => {
                  U.type === "Identifier" && p.push(U.name), (U.type === "BinaryExpression" || U.type === "ConditionalExpression") && T(U);
                });
              };
              switch (b.right.type) {
                case "ArrowFunctionExpression":
                case "ConditionalExpression":
                case "LogicalExpression":
                case "BinaryExpression":
                case "CallExpression":
                  T(b.right);
                  break;
              }
            })(d.value), S(a["custom-groups"], m);
            let N = {
              size: v(d.range),
              group: h(),
              dependencies: p,
              node: d,
              position: g,
              name: m
            };
            return c.at(-1).push(N), c;
          },
          [[]]
        );
        for (let r of o(n.properties))
          C(r, (c, d) => {
            let y = x(a.groups, c), m = x(a.groups, d);
            if (y > m || y === m && j(w(c, d, a))) {
              let g = (p) => {
                let h = {};
                for (let N of r) {
                  let E = x(a.groups, N);
                  E in h ? h[E] = A(
                    [...h[E], N],
                    a
                  ) : h[E] = [N];
                }
                let S = [];
                for (let N of Object.keys(h).sort())
                  S.push(...A(h[N], a));
                return P(p, r, S, e, {
                  partitionComment: a["partition-by-comment"]
                });
              };
              s.report({
                messageId: "unexpectedObjectsOrder",
                data: {
                  left: I(c.name),
                  right: I(d.name)
                },
                node: d.node,
                fix: g
              });
            }
          });
      }
    };
    return {
      ObjectExpression: l,
      ObjectPattern: l
    };
  }
}), re = "sort-classes", Ne = O({
  name: re,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted classes"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          groups: {
            type: "array",
            default: []
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedClassesOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    ClassBody: (l) => {
      if (l.body.length > 1) {
        let n = k(s.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1,
          groups: ["property", "constructor", "method", "unknown"]
        }), a = s.getSourceCode(), u = l.body.map((t) => {
          var d;
          let e, { getGroup: o, defineGroup: r } = M(n.groups);
          t.type === "StaticBlock" ? e = "static" : t.type === "TSIndexSignature" ? e = a.text.slice(
            t.range.at(0),
            ((d = t.typeAnnotation) == null ? void 0 : d.range.at(0)) ?? t.range.at(1)
          ) : t.key.type === "Identifier" ? { name: e } = t.key : e = a.text.slice(...t.key.range);
          let c = e.startsWith("_") || e.startsWith("#");
          if (t.type === "MethodDefinition") {
            t.kind === "constructor" && r("constructor");
            let y = t.accessibility === "private" || c, m = t.static;
            y && m && r("static-private-method"), y && r("private-method"), m && r("static-method"), t.kind === "get" && r("get-method"), t.kind === "set" && r("set-method"), r("method");
          } else
            t.type === "TSIndexSignature" ? r("index-signature") : t.type === "PropertyDefinition" && ((t.accessibility === "private" || c) && r("private-property"), t.static && r("static-property"), r("property"));
          return {
            size: v(t.range),
            group: o(),
            node: t,
            name: e
          };
        });
        C(u, (t, e) => {
          let o = x(n.groups, t), r = x(n.groups, e);
          t.name !== e.name && (o > r || o === r && j(w(t, e, n))) && s.report({
            messageId: "unexpectedClassesOrder",
            data: {
              left: I(t.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (c) => {
              let d = [], y = u.reduce(
                (g, p) => {
                  let h = x(n.groups, p);
                  return h in g ? g[h] = A(
                    [...g[h], p],
                    n
                  ) : g[h] = [p], g;
                },
                {}
              ), m = Object.keys(y).sort().reduce(
                (g, p) => [
                  ...g,
                  ...y[p]
                ],
                []
              );
              for (let g = 0, p = m.length; g < p; g++)
                d.push(
                  c.replaceTextRange(
                    G(u.at(g).node, a),
                    a.text.slice(
                      ...G(m.at(g).node, a)
                    )
                  )
                );
              return d;
            }
          });
        });
      }
    }
  })
}), se = "sort-enums", we = O({
  name: se,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted TypeScript enums"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedEnumsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    TSEnumDeclaration: (l) => {
      if (l.members.length > 1 && l.members.every(({ initializer: n }) => n)) {
        let n = k(s.options.at(0), {
          type: i.alphabetical,
          order: f.asc,
          "ignore-case": !1
        }), a = s.getSourceCode(), u = l.members.map((t) => ({
          name: t.id.type === "Literal" ? `${t.id.value}` : `${a.text.slice(...t.id.range)}`,
          size: v(t.range),
          node: t
        }));
        C(u, (t, e) => {
          j(w(t, e, n)) && s.report({
            messageId: "unexpectedEnumsOrder",
            data: {
              left: I(t.name),
              right: I(e.name)
            },
            node: e.node,
            fix: (o) => P(o, u, A(u, n), a)
          });
        });
      }
    }
  })
}), ae = "sort-maps", Ie = O({
  name: ae,
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted Map elements"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            enum: [
              i.alphabetical,
              i.natural,
              i["line-length"]
            ],
            default: i.alphabetical,
            type: "string"
          },
          order: {
            enum: [f.asc, f.desc],
            default: f.asc,
            type: "string"
          },
          "ignore-case": {
            type: "boolean",
            default: !1
          }
        },
        additionalProperties: !1
      }
    ],
    messages: {
      unexpectedMapElementsOrder: 'Expected "{{right}}" to come before "{{left}}"'
    }
  },
  defaultOptions: [
    {
      type: i.alphabetical,
      order: f.asc
    }
  ],
  create: (s) => ({
    NewExpression: (l) => {
      if (l.callee.type === "Identifier" && l.callee.name === "Map" && l.arguments.length && l.arguments[0].type === "ArrayExpression") {
        let [{ elements: n }] = l.arguments;
        if (n.length > 1) {
          let a = k(s.options.at(0), {
            type: i.alphabetical,
            "ignore-case": !1,
            order: f.asc
          }), u = s.getSourceCode(), t = n.reduce(
            (e, o) => (o === null || o.type === "SpreadElement" ? e.push([]) : e.at(-1).push(o), e),
            [[]]
          );
          for (let e of t) {
            let o = e.map((r) => {
              let c;
              if (r.type === "ArrayExpression") {
                let [d] = r.elements;
                d ? d.type === "Literal" ? c = d.raw : c = u.text.slice(...d.range) : c = `${d}`;
              } else
                c = u.text.slice(...r.range);
              return {
                size: v(r.range),
                node: r,
                name: c
              };
            });
            C(o, (r, c) => {
              j(w(r, c, a)) && s.report({
                messageId: "unexpectedMapElementsOrder",
                data: {
                  left: I(r.name),
                  right: I(c.name)
                },
                node: c.node,
                fix: (d) => P(d, o, A(o, a), u)
              });
            });
          }
        }
      }
    }
  })
}), Oe = "eslint-plugin-perfectionist";
let z = (s) => {
  let l = {
    [ee]: [
      "error",
      {
        groups: [
          "type",
          ["builtin", "external"],
          "internal-type",
          "internal",
          ["parent-type", "sibling-type", "index-type"],
          ["parent", "sibling", "index"],
          "object",
          "unknown"
        ],
        "custom-groups": {
          value: {},
          type: {}
        },
        "newlines-between": "always",
        "internal-pattern": ["~/**"]
      }
    ],
    [re]: [
      "error",
      {
        groups: [
          "index-signature",
          "static-property",
          "private-property",
          "property",
          "constructor",
          "static-method",
          "private-method",
          "method",
          ["get-method", "set-method"],
          "unknown"
        ]
      }
    ],
    [te]: [
      "error",
      {
        "partition-by-comment": !1
      }
    ],
    [J]: [
      "error",
      {
        "spread-last": !0
      }
    ],
    [W]: ["error"],
    [V]: ["error"],
    [X]: ["error"],
    [K]: ["error"],
    [q]: ["error"],
    [F]: ["error"],
    [H]: ["error"],
    [Q]: ["error"],
    [Y]: ["error"],
    [Z]: ["error"],
    [se]: ["error"],
    [ae]: ["error"]
  };
  return {
    rules: Object.fromEntries(
      Object.entries(l).map(([n, [a, u = {}]]) => [
        `perfectionist/${n}`,
        [a, Object.assign(u, s)]
      ])
    ),
    plugins: ["perfectionist"]
  };
};
const Te = {
  rules: {
    [J]: de,
    [V]: ce,
    [re]: Ne,
    [se]: we,
    [Z]: Ee,
    [ee]: Se,
    [Q]: be,
    [Y]: xe,
    [ae]: Ie,
    [K]: ge,
    [q]: ye,
    [F]: me,
    [te]: Ae,
    [W]: ue,
    [H]: he,
    [X]: fe
  },
  configs: {
    "recommended-alphabetical": z({
      type: i.alphabetical,
      order: f.asc,
      "ignore-case": !1
    }),
    "recommended-natural": z({
      type: i.natural,
      order: f.asc,
      "ignore-case": !1
    }),
    "recommended-line-length": z({
      type: i["line-length"],
      order: f.desc
    })
  },
  name: Oe
};
export {
  Te as default
};
